<<<<<<< HEAD
{- 
Single occurrence of a let binding that is a function application. It gets inlined by the
unconditional inlining optimization.

let 
  funApp :: Integer -> Integer
  funApp = (\x y -> addInteger x y) 4
in funApp 5

-}

(let
    (nonrec)
    (termbind
      (strict)
      (vardecl funApp (fun (con integer) (con integer)))
      [ (builtin addInteger) (con integer 4) ]
=======
(let
    (nonrec)
    (termbind (strict) (vardecl appNum (con integer)) (con integer 4))
    (termbind
      (strict)
      (vardecl addInteger (fun (con integer) (fun (con integer) (con integer))))
      (builtin addInteger)
    )
    (termbind
      (strict)
      (vardecl addInteger (fun (con integer) (fun (con integer) (con integer))))
      (lam x (con integer) (lam y (con integer) [ [ addInteger x ] y ]))
    )
    (termbind
      (nonstrict)
      (vardecl
        fAdditiveSemigroupInteger
        [ (lam a (type) (fun a (fun a a))) (con integer) ]
      )
      addInteger
    )
    (termbind
      (strict)
      (vardecl
        bad_name
        (all
          a
          (type)
          (fun [ (lam a (type) (fun a (fun a a))) a ] (fun a (fun a a)))
        )
      )
      (abs a (type) (lam v [ (lam a (type) (fun a (fun a a))) a ] v))
    )
    (termbind
      (strict)
      (vardecl funApp (fun (con integer) (con integer)))
      (lam
        eta
        (con integer)
        [
          [ [ { bad_name (con integer) } fAdditiveSemigroupInteger ] appNum ]
          eta
        ]
      )
>>>>>>> d7318048b (Add test of a let that is an application. Needs more investigation on this one.)
    )
    [ funApp (con integer 5) ]
)